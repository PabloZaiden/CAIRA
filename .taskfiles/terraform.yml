#  yaml-language-server: $schema=https://taskfile.dev/schema.json
# docs: https://taskfile.dev
---
version: "3"

includes:
  internal: internal.yml

tasks:
  # * Install Terraform
  install:terraform:
    desc: Install Terraform
    cmds:
      - task: internal:install:brew:tap
        vars:
          APP: hashicorp/tap
      - task: internal:install:brew
        vars:
          APP: hashicorp/tap/terraform
      - cmd: |
          wget -O - https://apt.releases.hashicorp.com/gpg | sudo gpg --batch --yes --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt -o DPkg::Lock::Timeout=-1 update \
            && sudo apt -o DPkg::Lock::Timeout=-1 install terraform -y
        platforms: [linux]

  # * Install Terraform-Docs
  install:terraform-docs:
    desc: Install Terraform-Docs
    vars:
      TERRAFORM_DOCS_VERSION: "v0.21.0"
      TERRAFORM_DOCS_URL: "https://github.com/terraform-docs/terraform-docs/releases/download/{{.TERRAFORM_DOCS_VERSION}}/terraform-docs-{{.TERRAFORM_DOCS_VERSION}}-{{.OS}}-{{.ARCH}}.tar.gz"
    cmds:
      - task: internal:install:brew
        vars:
          APP: terraform-docs
      - cmd: |
          download_url="{{.TERRAFORM_DOCS_URL}}"
          curl --location -o ~/terraform-docs.tar.gz "${download_url}" \
            && tar -xf ~/terraform-docs.tar.gz --directory ~/ \
            && rm -f ~/terraform-docs.tar.gz \
            && chmod +x ~/terraform-docs \
            && sudo mv ~/terraform-docs /usr/local/bin/
        platforms: [linux]

  # * Install TFLint
  install:tflint:
    desc: Install TFLint
    cmds:
      - task: internal:install:brew
        vars:
          APP: tflint
      - cmd: |
          curl -L {{.GH_CURL_AUTH}} -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash
        platforms: [linux]

  # * Install Terrascan
  install:terrascan:
    desc: Install Terrascan
    vars:
      TERRASCAN_VERSION: "1.19.9"
      TERRASCAN_OS:
        sh: |
          if [[ "{{.OS}}" == "darwin" ]]; then
            echo "Darwin"
          else
            echo "Linux"
          fi
      TERRASCAN_ARCH:
        sh: |
          if [[ "{{.ARCH}}" == "amd64" ]]; then
            echo "x86_64"
          else
            echo "{{.ARCH}}"
          fi
      TERRASCAN_URL: "https://github.com/tenable/terrascan/releases/download/v{{.TERRASCAN_VERSION}}/terrascan_{{.TERRASCAN_VERSION}}_{{.TERRASCAN_OS}}_{{.TERRASCAN_ARCH}}.tar.gz"
    cmds:
      - cmd: |
          curl -L "{{.TERRASCAN_URL}}" > ~/terrascan.tar.gz
          tar -xf ~/terrascan.tar.gz --directory ~/ terrascan \
            && rm -f ~/terrascan.tar.gz \
            && sudo install ~/terrascan /usr/local/bin/terrascan \
            && rm ~/terrascan

  # * Install terrafmt
  install:terrafmt:
    vars:
      TERRAFMT_VERSION: "v0.5.4"
      # NOTE: Using PabloZaiden/terrafmt-dist as the source for terrafmt prebuilt binaries instead of the original katbyte/terrafmt repository.
      # This repository is a trusted mirror/distribution point for prebuilt binaries, as the original does not provide them for all platforms.
      TERRAFMT_URL: "https://github.com/PabloZaiden/terrafmt-dist/releases/download/{{.TERRAFMT_VERSION}}/terrafmt-{{.TERRAFMT_VERSION}}-{{.OS}}-{{.ARCH}}"

    desc: Install terrafmt
    cmd: |
      download_url="{{.TERRAFMT_URL}}"
      echo "Downloading terrafmt from ${download_url}"
      curl -L {{.GH_CURL_AUTH}} -o ~/terrafmt "${download_url}" \
        && chmod +x ~/terrafmt \
        && sudo mv ~/terrafmt /usr/local/bin/

  # * Tools
  tools:
    desc: Install Terraform tools
    cmds:
      - task: install:terraform
      - task: install:terraform-docs
      - task: install:tflint
      - task: install:terrafmt
      - task: install:terrascan

  # * Lint
  lint:
    desc: Run Terraform linters
    cmds:
      - cmd: |
          terraform fmt -recursive
          tflint --init --config "$(pwd)/.github/linters/.tflint.hcl"
          tflint --recursive --fix --config "$(pwd)/.github/linters/.tflint.hcl"
      - cmd: |
          find . -type f -name "*.md" -not -path "*/.terraform/*" -exec terrafmt fmt {} --fix-finish-lines --quiet \;
    dir: "{{.ROOT_DIR}}"

  # * Docs
  docs:
    desc: Generate Terraform documentation
    cmds:
      - terraform-docs -c ./.github/configs/.terraform-docs.yml modules
      - terraform-docs -c ./.github/configs/.terraform-docs.yml reference_architectures
      - terraform-docs -c ./.github/configs/.terraform-docs.yml testing
    dir: "{{.ROOT_DIR}}"

  # * Clean
  clean:
    desc: Clean up Terraform files
    cmds:
      - cmd: |
          find ./ -name ".external_modules" -type d -exec rm -rf {} \;
          find ./ -name ".terraform" -type d -exec rm -rf {} \;
          find ./ -name "*.terraform.lock.*" -type f -exec rm -f {} \;
          find ./ -name "*.tfstate*" -type f -exec rm -f {} \;
    dir: "{{.ROOT_DIR}}"

  env:login:
    desc: Login to Azure for Terraform tests
    silent: true
    cmd: |
      # ensure az login
      if ! az account show &> /dev/null; then
        az login
      fi

  env:setup:
    desc: Set up Terraform test environment
    preconditions:
      - sh: |
          # verify az is logged in or ARM_SUBSCRIPTION_ID is set
          if [[ -z "${ARM_SUBSCRIPTION_ID:-}" ]]; then
            if ! az account show &> /dev/null; then
              exit 1
            fi
          fi
        msg: "Azure CLI is not logged in. Run task tf:env:login to authenticate."
    silent: true
    cmd: |
      # set ARM_SUBSCRIPTION_ID if not set
      if [[ -z "${ARM_SUBSCRIPTION_ID:-}" ]]; then
        echo "export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)"
      fi

  test:pools:deploy:
    desc: Deploy infrastructure pools for integration tests
    deps:
      - env:login
    silent: true
    cmd: |
      set -e

      export_azure_sub=$(task tf:env:setup)

      eval "$export_azure_sub"

      echo "Deploying Foundry Basic Private Pool..."
      pushd testing/infrastructure_pools/foundry_basic_private > /dev/null

      # if there is a terraform.tfstate file, skip init/apply
      if [[ -f "terraform.tfstate" ]]; then
        echo "Found existing terraform.tfstate file, skipping deployment."
      else
        terraform init
        terraform apply -auto-approve
      fi

      popd > /dev/null

      echo "Deploying Foundry Standard Private Pool..."
      pushd testing/infrastructure_pools/foundry_standard_private > /dev/null

      # if there is a terraform.tfstate file, skip init/apply
      if [[ -f "terraform.tfstate" ]]; then
        echo "Found existing terraform.tfstate file, skipping deployment."
      else
        terraform init
        terraform apply -auto-approve
      fi
      popd > /dev/null

  test:pools:outputs:
    desc: Output infrastructure pools for integration tests
    silent: true
    cmd: |
      set -e

      echo "Foundry Basic Private Pool outputs:"
      pushd testing/infrastructure_pools/foundry_basic_private > /dev/null
      terraform output
      popd > /dev/null

      echo "Foundry Standard Private Pool outputs:"
      pushd testing/infrastructure_pools/foundry_standard_private > /dev/null
      terraform output
      popd > /dev/null

  test:pools:outputs:env:
    desc: Export infrastructure pool outputs as environment variables
    silent: true
    cmd: |
      set -e

      # Durable Infrastructure Pools - Foundry Standard Private
      pushd testing/infrastructure_pools/foundry_standard_private > /dev/null
      echo "export TF_VAR_fsp_resource_group_name=\"$(terraform output -raw resource_group_name)\""
      echo "export TF_VAR_fsp_vnet_name=\"$(terraform output -json connection | jq -r '.virtual_network_name')\""
      echo "export TF_VAR_fsp_cosmosdb_account_name=\"$(terraform output -raw cosmosdb_account_name)\""
      echo "export TF_VAR_fsp_storage_account_name=\"$(terraform output -raw storage_account_name)\""
      echo "export TF_VAR_fsp_search_service_name=\"$(terraform output -raw search_service_name)\""
      popd > /dev/null

      # Durable Infrastructure Pools - Foundry Basic Private (Pool 1)
      pushd testing/infrastructure_pools/foundry_basic_private > /dev/null
      echo "export TF_VAR_fbp_resource_group_name=\"$(terraform output -raw resource_group_name)\""
      echo "export TF_VAR_fbp_vnet_name=\"$(terraform output -json connection | jq -r '.virtual_network_name')\""
      popd > /dev/null

  # * Run Acceptance Test
  test:acc:
    desc: Run terraform acceptance tests
    silent: true
    status:
      - test ! -d "tests/acceptance"
    cmds:
      - terraform init -upgrade -test-directory="tests/acceptance"
      - terraform test -test-directory="tests/acceptance" -junit-xml="testacc-results.xml" -verbose
    dir: "{{.USER_WORKING_DIR}}"

  test:acc:all:
    desc: Run terraform acceptance tests on all modules
    silent: true
    vars:
      ITEMS:
        sh: "task tf:get:modules -- ."
    cmds:
      - for: { var: ITEMS }
        cmd: |
          pushd "{{osClean .ITEM}}"
          task tf:test:acc
          popd
    dir: "{{.ROOT_DIR}}"

  # * Run Integration Test
  test:int:
    desc: Run terraform integration tests
    silent: true
    status:
      - test ! -d "tests/integration"
    cmds:
      - terraform init -upgrade -test-directory="tests/integration"
      - terraform test -test-directory="tests/integration" -junit-xml="testint-results.xml" -verbose
    dir: "{{.USER_WORKING_DIR}}"

  test:int:local:
    desc: Run terraform integration tests in local mode
    deps:
      - test:pools:deploy
    silent: true
    status:
      - test ! -d "tests/integration"
    cmd: |
      export_azure_sub=$(task tf:env:setup)

      eval "$export_azure_sub"

      export_pool_vars=$(task tf:test:pools:outputs:env)

      eval "$export_pool_vars"

      terraform init -upgrade -test-directory="tests/integration"
      terraform test -test-directory="tests/integration" -verbose

    dir: "{{.USER_WORKING_DIR}}"

  test:int:all:
    desc: Run terraform integration on all modules
    silent: true
    vars:
      ITEMS:
        sh: "task tf:get:modules -- ."
    cmds:
      - for: { var: ITEMS }
        cmd: |
          pushd "{{osClean .ITEM}}"
          task tf:test:int
          popd
    dir: "{{.ROOT_DIR}}"

  test:int:all:local:
    desc: Run terraform integration on all modules in local mode
    silent: true
    vars:
      ITEMS:
        sh: "task tf:get:modules -- ."
    cmds:
      - for: { var: ITEMS }
        cmd: |
          pushd "{{osClean .ITEM}}"
          task tf:test:int:local
          popd
    dir: "{{.ROOT_DIR}}"

  # * Run All Tests
  test:
    desc: Run all terraform tests (integration, acceptance) on all modules
    cmds:
      - echo "ðŸ”— Running Integration Tests..."
      - task: test:int:all
      - echo "âœ… Running Acceptance Tests..."
      - task: test:acc:all
      - echo "ðŸŽ‰ All tests completed!"
    dir: "{{.ROOT_DIR}}"

  get:modules:
    desc: Get all TF modules
    vars:
      PATH: "{{if empty .CLI_ARGS | not}}{{.CLI_ARGS}}{{else}}modules{{end}}"
    silent: true
    cmds:
      - cmd: find "{{osClean .PATH}}" -mindepth 2 -not -path "*/.*" -type f -name "*.tf" -exec dirname {} \; | sort -u
    dir: "{{.ROOT_DIR}}"
